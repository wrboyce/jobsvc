# Job Control System with gRPC API and CLI

A secure, minimal system for starting, stopping, and monitoring background jobs, with per-job resource controls implemented via Linux cgroups. Authorisation will be handled via mTLS with a simple auth scheme limiting users to only interact with jobs they started.

The system consists of three components:

- Library: responsible for process execution, output capture, and cgroup setup.
- API Server: a gRPC server handling auth and exposing job control functionality.
- CLI Client: a command-line interface for interacting with the API.

## Details

### Job Model

- Jobs are identified by a unique identifier generated by the library at creation.
- Jobs run as child processes in isolated cgroups.
- Output (stdout and stderr) is captured in-memory and exposed via the API.
- Only the client that created a job may interact with it.

### Job Lifecycle

#### Start

When a new job is created, the following steps are taken.

1. Unique ID is generated.
1. Cgroup is created and configured.
1. Process and output pipes are setup.
1. Goroutines are spawned to copy stdout/stderr to output buffer.
1. Process is started and moved into cgroup.
1. Goroutine is spawned waiting for job to finish.

#### Stop

When a job ends (manually, successfully ending, failing, or erroring on creation), some cleanup tasks are performed.

- Cgroup is deleted.
- Job status and exit_code are updated accordingly.
- Output subscriber channels are closed.

If a job is stopped before naturally ending (e.g. by `jobctl stop` command), then a `SIGTERM` will first be issued followed by a `SIGKILL` if the process does not end in a timely manner, the exit code will be set to either 0 (128+0) or 137 (128+9) depending on the signal which stopped the job, and the job status will be updated to `stopped`.

### Job Output

To facilitate streaming job output (possibly to multiple clients) the following setup is performed during job creation.

- The (combined stdout and stderr) output of each job is stored in memory.
- Goroutines copy from stdout/stderr into the job's output buffer.

When a client requests job output:

1. A new channel is created and added to the job's subscribers map.
1. The client is sent all historic output from the job's buffer.
1. New output chunks are broadcast to all subscriber channels.
1. If the job ends, all active streams will be closed.

### CLI Interface

Two binaries will be provided, `jobsvc` and `jobctl`.

Global flags `cert`, `key`, `ca` will be used for authentication. For simplicity the server and client will be limited to a hard coded host/port pairing.

#### Server

The `jobsvc` binary will be used to start the server and run in the foreground.

#### Client

The `jobctl` CLI interacts with the gRPC API to control jobs:

```console
$ jobctl start yes
job-id
$ jobctl stop job-id
$ jobctl status job-id
...see below...
$ jobctl logs job-id
...
```

No restart, delete, or resource flags are exposed — by design.

##### `status` Command

Displays the current state of a specific job by id. Output is presented in a simplified format inspired by `systemctl status`.

**Running job:**

```console
$ jobctl status job-id
Job:         job-id
Status:      running
Command:     yes
```

**Finished job (successful exit):**

```console
$ jobctl status job-id
Job:         job-id
Status:      finished
Command:     echo hello
Exit Code:   0
```

**Failed job (non-zero exit code):**

```console
$ jobctl status job-id
Job:         job-id
Status:      failed
Command:     curl http://localhost
Exit Code:   1
```

**Stopped job (SIGTERM):**

```console
$ jobctl status job-id
Job:         job-id
Status:      stopped
Command:     curl http://localhost
Exit Code:   0
```

**Stopped job (SIGKILL):**

```console
$ jobctl status job-id
Job:         job-id
Status:      stopped
Command:     curl http://localhost
Exit Code:   137
```

**Job creation error:**

```console
$ jobctl status job-id
Job:         job-id
Status:      error
Command:     foobar
```

Status classification:

- `running`: job is currently executing
- `finished`: job exited with code 0
- `failed`: job exited with non-zero code
- `stopped`: job was manually stopped by user
- `error`: job creation failed

Fields are aligned for readability. No structured (e.g. JSON) output is currently supported. Details of the reason for job creation failure have been omitted from the API for simplicity.

### gRPC API

The system exposes a gRPC API with endpoints for job lifecycle and log access.

#### Methods

- `StartJob`: Create a new job
- `StopJob`: Terminate a job
- `GetJobStatus`: Returns job metadata including status, full command (including args), and exit code (if available).
- `GetJobLogs`: Stream job output

See `jobsvc.proto` for full schema.

### Cgroups and Resource Limits

Upon creation, each job is placed into a unique cgroup with hardcoded resource limits:

| Resource | Interface    | Value                                            |
| -------- | ------------ | ------------------------------------------------ |
| CPU      | `cpu.max`    | `50000 100000` (50%)                             |
| Memory   | `memory.max` | `1073741824` (1 GiB)                             |
| IO Read  | `io.max`     | `default rbps=104857600` (100 MiB/s read limit)  |
| IO Write | `io.max`     | `default wbps=104857600` (100 MiB/s write limit) |

These values are written to appropriate cgroup v2 files under a per-job path. IO throttling is applied using a basic read bandwidth limit of 100 MiB/s on the default device. IOPS limits and device-specific control are not configured.

Failure to create or configure a cgroup for a job will result in job creation failing.

### Authentication and Authorization

All communication between client and server is authenticated using mTLS. Certificates will be generated using ED25519, and a minimum version of TLS1.3 will be required.

- Clients must present a valid X.509 certificate signed by the server CA.
- The Common Name (CN) of the certificate is treated as the client identity.

Authorization is enforced as follows:

- Clients may only access or modify jobs they created.
- The server tracks the CN of each job’s creator and compares it with the incoming request's identity.

No role-based access control or external identity systems are implemented, per scope constraints. Crucially, jobs execute with the same user privileges as the jobsvc server itself.

### Logging and Observability

The server writes basic logs to stderr for development and debugging:

- Job creation, start, stop, and exit
- Authorization failures
- Unexpected errors

No external observability systems (e.g. metrics, tracing) are implemented.

### Testing

Targeted tests will be written for:

- Authorization logic
- Output streaming
- Cgroup setup

Tests focus on both happy and error scenarios, without aiming for 100% coverage.

### Caveats and Simplifications

This project is intentionally scoped for a technical exercise and is not intended to be production-ready. The following caveats and simplifications apply:

- Resource limits are hardcoded and not configurable.
- Any valid client certificate grants full API access; job isolation is the only authorization mechanism enforced.
- There is no persistent state — jobs and logs are lost when the server process exits.
- Output is stored in-memory only and merged (stdout + stderr) without log rotation or truncation.
- No restart, delete or job listing functionality is implemented.
- The CLI is designed for human interaction only — it does not support structured output for programmatic use.
- No config files, runtime reloads, or environment-variable overrides are supported.

### Future Work

This system could be extended with:

- Restart policies and lifecycle hooks.
- Persistent job state (e.g. via embedded DB).
- Web UI or extended CLI.
- Configuration via env var and config file in addition to commandline arguments.
- Additional configuration where there are currently hardcoded values.
- Integration with audit logs, tracing, and Prometheus metrics.
- Namespace isolation or seccomp.

## Drawbacks

- Hardcoded resource limits may not suit all workloads.
- In-memory log storage is unbounded and ephemeral.
- No resilience to server crashes (jobs and logs lost on restart).
- Trust is entirely based on certificate CNs.
- All jobs will be run as the system superuser (or whichever user started the job server).
